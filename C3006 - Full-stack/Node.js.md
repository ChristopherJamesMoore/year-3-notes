<h3>Client-server architecture</h3>
<b>Web servers</b>
A piece of software that receives HTTOP requests and serves the appropriate content.
- Static web pages
- Dynamic content generated by running a server-side program
- Structured data (JSON, XML, etc...)
- Images, sound, video, etc...
![[Pasted image 20250930092555.png]]
<h3>HTTP protocol</h3>
HTTP messages are used to pass information around the web.
- Messages have a <b>header</b> and <b>body</b>
- Header defines
	- <i>Where the message came from</i>
	- <i>Where it is going</i>
	- <i>The payload type (HTML, images, JSON, etc...)</i>
	- <i>Other...</i>
- Body contains the payload (content of the message)
- HTTP is stateless - to preserve state use a cookie (or similar)

<b>HTTP request methods: GET or POST</b>
<b><u><i>GET</b></u></i>
- For fetching static data to display
- Fast
- Returns browser buffered value for identical requests
- Size limited (2048 chars)
- Data to server passed in URL query string
<b><u><i>POST</b></u></i>
- For updating server, effecting server-side changes
- Identical calls may produce different responses
- Not buffered
- Slower
- No size limit
<i>Others include PUT, DELETE...</i>

<h3>Node.js overview</h3>
Node.js is a server-side programming environment based on JavaScript.
- Node installation sits alongside web-server used to produce dynamic content
- Event driven
- Asynchronous non-blocking - good for streaming
- Cross platform
- Many packages add functionality

<h3>Node.js "Hello World" web-server <font color="red">*</font></h3>
1. Include required Node modules and define a port
2. Initialise the server, to return a message
3. Listen for requests

````
server.js

let http = require("http");
let port = 9000; 

let server = http.createServer(function(request, response) { 
response.setHeader("Content-Type", "text/plain");
response.writeHead(200);
response.end("Hello World from Node"); });
server.listen(port, function() { console.log("Server listening on port " + port); });
````

<h3>Node.js: Running the server <font color="red">*</font></h3>
<u>Option 1: Terminal</u>
- Installing Node.js directly to machine:
````
brew install node
````
- Run server application using:
````
node server.js
````
<u>Option 2: using Docker</u>
````
compose.yaml
services:
	web:
		image: node:22.9.0
		volumes:
			- ./app:/usr/src/app
		ports:
			- "82:9000"
		working_dir: /usr/src/app
		command: sh -c "
			chmod +x run.sh &&
			./run.sh"
````

<h3>Functions</h3>
- Functions have names, although sometimes they can be anonymous.
- Arguments
- Return values
````
function sum (x, y) {
	return x + y;
}

window.onload = function() {
	let result = sum (5, 12);
	console.log("result is " + result)'
}
````

- All functions have an array of arguments - called <font color="blue">arguments</font>
- Used to pass an arbitrary number of function arguments
````
function sumArr() {
	let result = 0;
	for (i = 0; i < arguments.length; i++) {
		result += arguments [i];
	}
	return result
}

window.onload = function() {
	let result = sumArr (5, 12, 19, 85);
	console.log("result is " + result)'
}
````

<b>Function passing</b>
Functions can be passed as arguments to other functions
````
function product (x, y) {
	return x * y;
}

function calc (func, x, y) {
	return func (x, y);
}

window.onload = function() {
	console.log ("sum is " + calc(sum, 5, 12));
	console.log ("product is " + calc (product, 5, 12));
} 
````

<b>Arrays of functions</b>
Functions can be stored in arrays
````
function subtract (x, y) {
	return x - y;
}

window.onload = function() {
	let arr = [sum, product, subtract];

	for (i = 0; arr.length; i++) {
		console.log (arr[i].name + " " + arr [i] (5, 12));
	}
}
````

<b>Arrow functions <font color="red">*</font></b>
````
output = (args) => { statements };
````

So the function
````
window.onload = function() {
	let square = (x) => { return x * x; }
	
	console.log (square (4));
	console.log (square (10));
}
````
Is the same as
````
function square (x) {
	return x * x;
}

````
- Shorter code than normal syntax
- Have limitations (such as cannot act as <font color="blue">constructor</font> for objects)

<h3>Events</h3>
Asynchronous programming
- JavaScript is an asynchronous language
- Events fire when something happens (e.g., in the UI) that needs to be handled
- Functions handle events
- Attach handlers with <font color="blue">addEventListener</font> (native JS)
````
window.onload = function {
	set elem = document.getElementById ("document");
	elem.addEventListener ("keypress", function (evt){
		console.log ("key pressed " + evt.keycode);
	)};
}
````

<h3>Variable scope</h3>
<b>Global variables</b>
<i>Variables declared outside of a function are global</i>
- Global variables are visible to all functions
- Global variables live for as long as the application is running
Variables that have a value assigned to them before they are declared are automatically made global. In HTML global variables belong to the window object.
````
window.myCounter;
````

<b>Variables hoisting</b>
Variables declared in the middle of a function exist with a value undefined as soon as the function starts executing
- JS moves the variable declaration to the top of the file execution starts
Referring to a non-existing variable causes an error
Referring to a non-instantiated variable is OK (value is undefined)
````
let x
````

Hoisting example
````
window.onload = function() {
	myVar = "This is my variable";
	alert (myVar);
	let myVar;
}
````

Non-instantiated variable example
````
window.onload = function() {
	alert (myVar);
	myVar = "This is my variable";
	let myVar;
}
````

<h3>Scope</h3>
- Local variables are only visible to some functions
- These functions make up the scope of the variable
````
window.onload = function() {
	if (true) {
		let x = 1000;
		console.log (x);
	}
	console.log (x);
}
````

<i>No block scope</i>
- JS does not have block scope like C#
- Be careful with loops
- There is only function scoping
- the <font color="blue">let</font> keyword introduces block scope

<b>JavaScript scoping</b>
- JavaScript gives function objects a scope object or closure to record local variables
- The closure also contains a link to the closure of outer functions to keep their variables in scope
- The link of closure or scope chain is defined based on where the functions are declared, not where they are called
````
window.onload = function() {
	function sum (x) {
		return function (y) {
			return x + y;
		}
	}
	
	console.log (sum (5) (12));
}
````

<h3>Client-side debugging</h3>
<b>Runtime code analysis</b>
Watch code whilst it executes
- Variables
- Exceptions/ errors
<i>Debugging with breakpoints</i>
- A breakpoint is an intentional stopping or pausing place in a program
- Use breakpoints in DevTools to debug JavaScript, DOM updates and network calls

<b>Its a good idea to add & remove breakpoints for debugging</b>

<b>Printing stack traces</b>

Printing log messages to the DevTools console is very helpful in understanding how an application behaves. 

You can make the log entires even more informative y including associated stac traces - there are several ways of doing that:
- console.log & Error.stack 
- console.trace()

<b>Catching errors</b>

<u>Syntax errors</u>
- The interpreter cannot make sense of the program
<u>Runtime errors</u>
- Cannot read properties of null
- Exceptions
<u>Logical/ semantic erros</u>
- The program does not do the right thing
